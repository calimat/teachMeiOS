name: Deploy to TestFlight

on:
  push:
    branches:
      - development
      - rh/fix-provisioning-profile-name

env:
  XCODE_VERSION: '16.2'
  BUNDLE_IDENTIFIER: 'petitcoding.com.teachMe'
  DEVELOPMENT_TEAM: 'AMLYNCKP6M'
  PROVISIONING_PROFILE_SPECIFIER: 'TeachMeIOS'

jobs:
  build-and-deploy:
    runs-on: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Select Xcode version
        run: sudo xcode-select -s /Applications/Xcode_${{ env.XCODE_VERSION }}.app/Contents/Developer

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install CocoaPods
        run: |
          sudo gem install cocoapods
          pod install

      - name: Run Unit Tests
        run: |
          xcodebuild test \
            -workspace teachMe.xcworkspace \
            -scheme teachMe \
            -destination 'platform=iOS Simulator,name=iPhone 16,OS=18.2' \
            -skip-testing:teachMeTests/FirebaseIntegrationTests \
            -resultBundlePath ${{ runner.temp }}/TestResults \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            | xcpretty --color && exit ${PIPESTATUS[0]}

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-results
          path: ${{ runner.temp }}/TestResults

      - name: Import Code Signing Certificates
        env:
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        run: |
          # Create keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate with secure permissions
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERT_PATH"
          chmod 600 "$CERT_PATH"

          security import "$CERT_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$P12_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # Set keychain as default
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Import Provisioning Profile
        env:
          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Decode and install provisioning profile with correct UUID filename
          PROFILE_PATH="$RUNNER_TEMP/profile.mobileprovision"
          echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > "$PROFILE_PATH"

          # Extract UUID from provisioning profile
          UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i "$PROFILE_PATH"))

          # Copy to Xcode provisioning profiles directory with UUID as filename
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PROFILE_PATH" "$HOME/Library/MobileDevice/Provisioning Profiles/$UUID.mobileprovision"

          echo "Installed provisioning profile with UUID: $UUID"

      - name: Get Latest Build Number from App Store Connect
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
        run: |
          set -e

          # Decode API key
          API_KEY_PATH="$RUNNER_TEMP/AuthKey.p8"
          echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 --decode > "$API_KEY_PATH"

          # Generate JWT token for App Store Connect API
          HEADER=$(printf '{"alg":"ES256","kid":"%s","typ":"JWT"}' "$APP_STORE_CONNECT_API_KEY_ID" | openssl base64 -A | tr '+/' '-_' | tr -d '=')
          NOW=$(date +%s)
          EXP=$((NOW + 1200))
          PAYLOAD=$(printf '{"iss":"%s","exp":%d,"aud":"appstoreconnect-v1"}' "$APP_STORE_CONNECT_ISSUER_ID" "$EXP" | openssl base64 -A | tr '+/' '-_' | tr -d '=')

          SIGNATURE=$(printf '%s.%s' "$HEADER" "$PAYLOAD" | openssl dgst -sha256 -sign "$API_KEY_PATH" -binary | openssl base64 -A | tr '+/' '-_' | tr -d '=')
          JWT="${HEADER}.${PAYLOAD}.${SIGNATURE}"

          # Get app ID from bundle identifier
          echo "Fetching app ID for bundle: ${{ env.BUNDLE_IDENTIFIER }}"
          HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RUNNER_TEMP/app_response.json" -H "Authorization: Bearer $JWT" \
            "https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]=${{ env.BUNDLE_IDENTIFIER }}")
          APP_RESPONSE=$(cat "$RUNNER_TEMP/app_response.json")
          echo "HTTP Status: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "API request failed with status $HTTP_CODE"
            echo "Response: $APP_RESPONSE"
            exit 1
          fi

          # Check if response is valid JSON
          if ! echo "$APP_RESPONSE" | jq . > /dev/null 2>&1; then
            echo "Error: Response is not valid JSON"
            echo "Response: $APP_RESPONSE"
            exit 1
          fi

          # Check for API errors
          if echo "$APP_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
            echo "API Error:"
            echo "$APP_RESPONSE" | jq '.errors'
            exit 1
          fi

          APP_ID=$(echo "$APP_RESPONSE" | jq -r '.data[0].id // empty')
          if [ -z "$APP_ID" ]; then
            echo "Error: Could not find app ID"
            echo "Response: $APP_RESPONSE"
            exit 1
          fi
          echo "App ID: $APP_ID"

          # Get latest build number
          echo "Fetching latest build number..."
          HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RUNNER_TEMP/builds_response.json" -H "Authorization: Bearer $JWT" \
            "https://api.appstoreconnect.apple.com/v1/builds?filter[app]=$APP_ID&sort=-version&limit=1")
          BUILDS_RESPONSE=$(cat "$RUNNER_TEMP/builds_response.json")
          echo "HTTP Status: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "API request failed with status $HTTP_CODE"
            echo "Response: $BUILDS_RESPONSE"
            exit 1
          fi

          # Check for API errors
          if echo "$BUILDS_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
            echo "API Error:"
            echo "$BUILDS_RESPONSE" | jq '.errors'
            exit 1
          fi

          LATEST_BUILD=$(echo "$BUILDS_RESPONSE" | jq -r '.data[0].attributes.version // "0"')
          echo "Latest build in App Store Connect: $LATEST_BUILD"

          # Increment build number
          if ! [[ "$LATEST_BUILD" =~ ^[0-9]+$ ]]; then
            echo "Warning: Latest build '$LATEST_BUILD' is not a number, defaulting to 0"
            LATEST_BUILD=0
          fi
          NEW_BUILD=$((LATEST_BUILD + 1))
          echo "New build number: $NEW_BUILD"

          # Update Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $NEW_BUILD" teachMe/Info.plist

          # Clean up
          rm -f "$API_KEY_PATH"

      - name: Build Archive
        run: |
          xcodebuild archive \
            -workspace teachMe.xcworkspace \
            -scheme teachMe \
            -configuration Release \
            -archivePath "$RUNNER_TEMP/teachMe.xcarchive" \
            -allowProvisioningUpdates \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${{ env.DEVELOPMENT_TEAM }}"

      - name: Export IPA
        run: |
          # Create export options plist
          cat > "$RUNNER_TEMP/ExportOptions.plist" << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store</string>
            <key>teamID</key>
            <string>${{ env.DEVELOPMENT_TEAM }}</string>
            <key>uploadBitcode</key>
            <false/>
            <key>compileBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>signingStyle</key>
            <string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${{ env.BUNDLE_IDENTIFIER }}</key>
              <string>${{ env.PROVISIONING_PROFILE_SPECIFIER }}</string>
            </dict>
          </dict>
          </plist>
          EOF

          # Export archive to IPA
          xcodebuild -exportArchive \
            -archivePath "$RUNNER_TEMP/teachMe.xcarchive" \
            -exportPath "$RUNNER_TEMP/export" \
            -exportOptionsPlist "$RUNNER_TEMP/ExportOptions.plist"

      - name: Upload to TestFlight
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
        run: |
          # Create API key directory
          API_KEY_DIR="$HOME/.appstoreconnect/private_keys"
          API_KEY_PATH="$API_KEY_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"
          mkdir -p "$API_KEY_DIR"

          # Save API key to file with base64 decoding and secure permissions
          echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 --decode > "$API_KEY_PATH"
          chmod 600 "$API_KEY_PATH"

          # Upload to TestFlight
          xcrun altool --upload-app \
            -f "$RUNNER_TEMP/export/teachMe.ipa" \
            -t ios \
            --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
            --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID"

      - name: Clean up sensitive files
        if: always()
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        run: |
          # Remove keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH"
          fi

          # Remove certificate file
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          if [ -f "$CERT_PATH" ]; then
            rm -f "$CERT_PATH"
          fi

          # Remove API key file
          API_KEY_PATH="$HOME/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"
          if [ -f "$API_KEY_PATH" ]; then
            rm -f "$API_KEY_PATH"
          fi

      - name: Upload build artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            ${{ runner.temp }}/*.log
